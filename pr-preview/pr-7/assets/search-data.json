[{"id":"1","title":"Command Line Interface","content":"Command Line Interface The CLI is the runtime entry-point for a generated modular services config. It validates the config, runs startup hooks, launches services, and streams their logs until shutdown. Intended use is meant to be the final step after evaluating a modular services configuration with . It is lightweight enough for containers, but still gives you consistent startup, restart, and shutdown behavior. Basic flow Generate a JSON config using . Run to check it. Run to launch services. Commands : read and deserialize the config to ensure it is well-formed. : start the process manager and run all configured services. Flags , : path to the generated JSON configuration file. Runtime behavior Optional startup binary runs once before services start. Each service runs with a clean environment and its configured . Service logs stream to stdout/stderr with the service name as the log target. Restart behavior follows ( , , ). triggers a graceful shutdown and waits for services to exit. Example","path":"cli.html","tokens":["manager","you","services","entry-point","process","shutdown","line","flags","hooks","final","runs","startup","and","until","flow","path","file","stdout","containers","meant","cli","launches","basic","consistent","environment","with","clean","each","their","exit","generated","deserialize","run","example","command","but","all","modular","read","before","target","evaluating","launch","stderr","graceful","enough","its","restart","waits","gives","configuration","the","after","interface","logs","lightweight","generate","validates","well-formed","step","json","start","service","name","follows","triggers","behavior","optional","stream","commands","binary","once","config","use","still","check","configured","ensure","streams","for","intended","log","using","runtime"],"title_tokens":["line","command","interface"],"anchors":[{"text":"Command Line Interface","id":"command-line-interface","level":1,"tokens":["command","interface","line"]},{"text":"Intended use","id":"intended-use","level":1,"tokens":["intended","use"]},{"text":"Basic flow","id":"basic-flow","level":1,"tokens":["basic","flow"]},{"text":"Commands","id":"commands","level":1,"tokens":["commands"]},{"text":"Flags","id":"flags","level":1,"tokens":["flags"]},{"text":"Runtime behavior","id":"runtime-behavior","level":1,"tokens":["runtime","behavior"]},{"text":"Example","id":"example","level":1,"tokens":["example"]}]},{"id":"2","title":"Nimi","content":"is a tiny process manager built for running NixOS modular services in containers and other minimal environments. It turns a NixOS modular services configuration into a reliable, lightweight runtime that starts services, streams logs, and applies predictable restart and startup behavior. Why Modular services are composable Nix modules: you can import a service, override options, and instantiate it multiple times with different settings. is the runtime that brings those modules to life outside a full init system (i.e. ). If you are new to modular services, the upstream explanation is the best place to start: NixOS Modular Services Manual . What's in the box A small PID 1 style runtime suitable for containers. Clean process execution with structured startup and shutdown flow. Configurable restart behavior for resilient services. One-time startup hook for quick initialization steps. Clear, instance-per-service configuration using modular services. Usage Define services using modular service modules. Evaluate the config with to produce JSON. Run with the generated config to launch and supervise services. Quick-start Minimal Nix configuration: Run the generated config: Configuration highlights : declare named service instances by importing modular service modules and overriding options per instance. : choose , , or , and tune delay and retry count. : optionally run one binary before services start. : define per-service config files; see . Next steps Explore service definitions and compose them per environment. Use restart policies to match reliability needs. Add a startup hook for migrations, warm-ups, or one-time init tasks.","path":"index.html","tokens":["new","running","and","resilient","definitions","warm-ups","minimal","tiny","manager","into","migrations","launch","them","starts","per","retry","behavior","outside","built","needs","flow","usage","run","system","count","logs","instance","add","reliability","other","tune","upstream","why","modular","box","manual","that","shutdown","configuration","full","lightweight","style","named","start","quick-start","with","small","best","explanation","the","importing","services","service","execution","import","one","json","instances","see","override","process","initialization","those","next","quick","are","times","init","evaluate","produce","for","before","match","restart","overriding","explore","environment","choose","modules","one-time","what","reliable","using","turns","environments","life","clean","declare","generated","clear","binary","compose","define","pid","can","containers","per-service","nix","instantiate","suitable","highlights","instance-per-service","composable","policies","tasks","you","multiple","hook","brings","predictable","supervise","runtime","startup","different","structured","place","files","delay","nixos","configurable","steps","use","config","applies","options","streams","optionally","settings"],"title_tokens":["nimi"],"anchors":[{"text":"Nimi","id":"nimi","level":1,"tokens":["nimi"]},{"text":"Why Nimi","id":"why-nimi","level":1,"tokens":["nimi","why"]},{"text":"What's in the box","id":"what-s-in-the-box","level":1,"tokens":["box","what","the"]},{"text":"Usage","id":"usage","level":1,"tokens":["usage"]},{"text":"Quick-start","id":"quick-start","level":1,"tokens":["quick-start"]},{"text":"Configuration highlights","id":"configuration-highlights","level":1,"tokens":["highlights","configuration"]},{"text":"Next steps","id":"next-steps","level":1,"tokens":["next","steps"]}]},{"id":"3","title":"Config Data Files","content":"Config Data Files lets modular service modules supply config files to a service instance. treats the entries in the generated JSON as the final, resolved files to expose. At runtime, for each service: serializes the service's entries, hashes them, and creates a temp directory (usually under ) named . Each is symlinked into that directory at the relative location. The service is started with set to the temp directory, so it can read config files at . does not render itself; the Nix evaluation/build step generates the files and the JSON points at them. Hence, updating the content requires rebuilding the config and restarting .","path":"config-data.html","tokens":["nix","service","treats","build","step","generates","itself","and","that","resolved","read","hence","into","does","updating","requires","serializes","started","generated","directory","modules","final","modular","temp","supply","relative","can","rebuilding","the","with","lets","json","not","expose","set","render","data","under","location","evaluation","for","points","symlinked","runtime","content","named","restarting","them","each","config","instance","creates","usually","hashes","files","entries"],"title_tokens":["files","data","config"],"anchors":[{"text":"Config Data Files","id":"config-data-files","level":1,"tokens":["config","data","files"]}]},{"id":"4","title":"Flake Module","content":"Flake Module The flake module output ( ) wires into a setup. It takes named service definitions and turns them into runnable binaries and container images, so you can build local runners, CI checks, and deployable artifacts from one source of truth. What it provides For each entry, the module generates: : a runtime binary built from the services module. : a container image bundling that runtime. and : the same outputs, wired into CI. Minimal example Build or run the outputs: Notes The module is designed for and expects entries. Outputs are generated per system, so each target platform gets its own runner.","path":"flake-module.html","tokens":["local","platform","runnable","each","run","wires","runners","turns","deployable","own","one","checks","binaries","gets","are","services","build","example","image","per","from","entries","generates","artifacts","generated","container","designed","source","binary","target","runner","output","that","the","built","outputs","bundling","same","runtime","setup","for","them","entry","flake","expects","definitions","minimal","system","can","into","service","images","module","you","what","takes","wired","its","and","provides","named","truth","notes"],"title_tokens":["flake","module"],"anchors":[{"text":"Flake Module","id":"flake-module","level":1,"tokens":["module","flake"]},{"text":"What it provides","id":"what-it-provides","level":2,"tokens":["provides","what"]},{"text":"Minimal example","id":"minimal-example","level":2,"tokens":["example","minimal"]},{"text":"Notes","id":"notes","level":2,"tokens":["notes"]}]},{"id":"5","title":"Option: _module.args","content":"Additional arguments passed to each module in addition to ones like , , and , . This option is also available to all submodules. Submodules do not inherit args from their parent module, nor do they provide args to their parent module or sibling submodules. The sole exception to this is the argument which is provided by parent modules to a submodule and contains the attribute name the submodule is bound to, or a unique generated name if it is not bound to an attribute. Some arguments are already passed by default, of which the following cannot be changed with this option: {var} : The nixpkgs library. {var} : The results of all options after merging the values from all modules together. {var} : The options declared in all modules. {var} : The argument passed to . All attributes of {var} Whereas option values can generally depend on other option values thanks to laziness, this does not apply to , which must be computed statically before anything else. For this reason, callers of the module system can provide which are available during import resolution. For NixOS, includes {var} , which allows you to import extra modules from the nixpkgs package tree without having to somehow make the module aware of the location of the or NixOS directories. For NixOS, the default value for this option includes at least this argument: {var} : The nixpkgs package set according to the {option} option.","path":"options.html#option-_module-args","tokens":["changed","you","additional","exception","bound","some","includes","together","each","nor","ones","results","computed","can","must","reason","also","sibling","extra","during","attribute","the","without","module","aware","args","from","make","callers","apply","else","their","location","declared","cannot","after","contains","they","sole","are","anything","statically","nixos","with","allows","following","provided","modules","library","resolution","for","available","and","addition","this","submodules","arguments","option","not","generated","already","inherit","generally","which","before","system","name","import","package","attributes","submodule","does","parent","tree","depend","var","having","somehow","directories","provide","argument","like","nixpkgs","whereas","passed","other","thanks","least","values","according","default","merging","unique","options","laziness","value","all","set"],"title_tokens":["_module","option","args"],"anchors":[]},{"id":"6","title":"Option: services","content":"Services to run inside the nimi runtime. Each attribute defines a named modular service: a reusable, composable module that you can import, extend, and tailor for each instance. This gives you clear service boundaries, easy reuse across projects, and a consistent way to describe how each process should run. The option is an submodule: the attribute name is the service name, and the module content defines its behavior. You typically provide a service by importing a module from a package and then overriding or extending its options. For the full upstream explanation and portability model, see the NixOS manual section on Modular Services .","path":"options.html#option-services","tokens":["package","describe","services","each","projects","full","you","clear","module","behavior","from","process","see","importing","its","nixos","provide","across","modular","extending","name","options","defines","upstream","import","submodule","content","composable","manual","overriding","easy","runtime","extend","way","run","reusable","this","can","then","attribute","that","reuse","should","explanation","inside","consistent","gives","the","tailor","model","boundaries","instance","portability","typically","how","named","option","and","for","nimi","service","section"],"title_tokens":["services","option"],"anchors":[]},{"id":"7","title":"Option: settings.container","content":"Configures nimi's builtin container generation. Note that none of these options will have any effect unless you are using to build your containers. These are mappings to 's function, please check there for further documentation.","path":"options.html#option-settings-container","tokens":["builtin","will","generation","mappings","there","any","you","have","check","build","nimi","note","these","containers","using","please","container","your","further","that","function","options","unless","are","for","documentation","configures","effect","none"],"title_tokens":["settings","container","option"],"anchors":[]},{"id":"8","title":"Option: settings.container.copyToRoot","content":"A derivation (or list of derivations) copied in the image root directory (store path prefixes are removed, in order to relocate them at the image ). can be used to build a derivation which has to be copied to the image root. For instance, to get bash and coreutils in the image :","path":"options.html#option-settings-container-copyToRoot","tokens":["order","and","which","directory","relocate","build","them","list","removed","can","path","root","derivations","are","the","store","image","has","for","instance","get","coreutils","copied","derivation","prefixes","bash","used"],"title_tokens":["settings","option","container","copytoroot"],"anchors":[]},{"id":"9","title":"Option: settings.container.fromImage","content":"An image that is used as base image of this image; Use or to supply this.","path":"options.html#option-settings-container-fromImage","tokens":["supply","use","base","this","used","that","image"],"title_tokens":["option","container","settings","fromimage"],"anchors":[]},{"id":"10","title":"Option: settings.container.initializeNixDatabase","content":"To initialize the Nix database with all store paths added into the image. Note this is only useful to run nix commands from the image, for instance to build an image used by a CI to run Nix builds.","path":"options.html#option-settings-container-initializeNixDatabase","tokens":["added","run","database","into","the","paths","useful","from","build","all","store","image","initialize","builds","for","nix","instance","commands","used","with","only","this","note"],"title_tokens":["container","initializenixdatabase","option","settings"],"anchors":[]},{"id":"11","title":"Option: settings.container.layers","content":"A list of layers built with the function. If a store path in deps or contents belongs to one of these layers, this store path is skipped. This is pretty useful to isolate store paths that are often updated from more stable store paths, to speed up build and push time.","path":"options.html#option-settings-container-layers","tokens":["list","contents","build","skipped","belongs","paths","with","store","updated","are","isolate","speed","the","path","built","these","useful","that","often","from","stable","pretty","more","push","time","function","one","and","layers","deps","this"],"title_tokens":["container","settings","option","layers"],"anchors":[]},{"id":"12","title":"Option: settings.container.maxLayers","content":"The maximum number of layers to create. This is based on the store path \"popularity\" as described in this blog post . Note this is applied on the image layers and not on layers added with the attribute.","path":"options.html#option-settings-container-maxLayers","tokens":["not","number","maximum","this","added","create","based","store","post","applied","note","attribute","and","popularity","image","the","described","blog","layers","with","path"],"title_tokens":["settings","container","option","maxlayers"],"anchors":[]},{"id":"13","title":"Option: settings.container.name","content":"The name of the generated image","path":"options.html#option-settings-container-name","tokens":["name","generated","image","the"],"title_tokens":["option","settings","container","name"],"anchors":[]},{"id":"14","title":"Option: settings.container.perms","content":"A list of file permisssions which are set when the tar layer is created: these permissions are not written to the Nix store.","path":"options.html#option-settings-container-perms","tokens":["set","written","which","layer","tar","file","these","are","list","store","the","created","permissions","nix","not","when","permisssions"],"title_tokens":["option","settings","perms","container"],"anchors":[]},{"id":"15","title":"Option: settings.container.tag","content":"The tag for the generated image to use","path":"options.html#option-settings-container-tag","tokens":["for","the","use","image","generated","tag"],"title_tokens":["settings","tag","option","container"],"anchors":[]},{"id":"16","title":"Option: settings.restart","content":"Restart policy for the nimi process manager. Use this to control if and how services are restarted after they exit. This is the main safety net for keeping long-running services alive, and also a guardrail to prevent tight restart loops from burning CPU. You can choose a policy that matches the reliability needs of each deployment. For development you might disable restarts entirely, while production workloads usually benefit from a bounded or always-on policy.","path":"options.html#option-settings-restart","tokens":["keeping","restarts","the","are","development","nimi","for","net","from","restart","prevent","safety","can","matches","reliability","disable","while","production","long-running","that","you","usually","use","each","control","and","how","process","after","exit","also","loops","cpu","entirely","manager","deployment","workloads","choose","benefit","burning","bounded","guardrail","needs","services","alive","might","policy","main","restarted","they","tight","this","always-on"],"title_tokens":["settings","restart","option"],"anchors":[]},{"id":"17","title":"Option: settings.restart.count","content":"Maximum number of restart attempts when is . Once this limit is reached, the service is left stopped until you intervene or change the configuration.","path":"options.html#option-settings-restart-count","tokens":["reached","maximum","when","this","stopped","number","attempts","service","left","until","restart","once","the","you","limit","configuration","intervene","change"],"title_tokens":["settings","restart","count","option"],"anchors":[]},{"id":"18","title":"Option: settings.restart.mode","content":"Selects the restart behavior. : do not restart failed services. : restart up to times, then stop. : always restart on failure. Choose if you want a service to get a few retries during a transient failure, but still fail fast when the issue is persistent. Choose when continuous availability matters more than surfacing the failure.","path":"options.html#option-settings-restart-mode","tokens":["selects","get","few","fast","then","always","persistent","services","stop","want","not","fail","choose","availability","more","restart","matters","but","failure","times","you","the","behavior","service","surfacing","during","retries","when","issue","transient","than","continuous","failed","still"],"title_tokens":["restart","option","settings","mode"],"anchors":[]},{"id":"19","title":"Option: settings.restart.time","content":"Delay between restarts in milliseconds. Increase this value for crash loops to give the system time to recover resources or for dependent services to come back.","path":"options.html#option-settings-restart-time","tokens":["recover","come","delay","this","give","dependent","system","value","for","resources","services","crash","back","between","restarts","increase","the","time","milliseconds","loops"],"title_tokens":["restart","time","settings","option"],"anchors":[]},{"id":"20","title":"Option: settings.startup","content":"Startup behavior for the nimi process manager. This section lets you run a one-time initialization command before any configured services are started. It is useful for bootstrapping state, preparing directories, or running a short setup task that should happen once per process manager start. The command is executed once and then the normal service startup proceeds. If you do not need a startup hook, leave it unset.","path":"options.html#option-settings-startup","tokens":["one-time","short","are","for","lets","started","section","per","any","services","then","not","need","executed","hook","running","directories","configured","behavior","proceeds","the","process","command","leave","startup","manager","run","setup","task","bootstrapping","that","start","and","useful","unset","state","preparing","once","this","nimi","before","happen","normal","should","initialization","service","you"],"title_tokens":["startup","settings","option"],"anchors":[]},{"id":"21","title":"Option: settings.startup.runOnStartup","content":"Path to a binary to run once at startup. This should be a single executable in the Nix store, not a shell snippet. Use to turn a package or derivation into a runnable path. The command runs before services start, so it is a good place to create files, check preconditions, or populate caches. If you need a long-running process, configure it as a service instead. Set to to disable.","path":"options.html#option-settings-startup-runOnStartup","tokens":["start","startup","store","runs","path","services","set","use","command","not","snippet","place","nix","runnable","turn","into","single","derivation","preconditions","package","process","instead","this","once","run","long-running","check","executable","configure","populate","disable","good","create","the","caches","you","binary","files","before","should","shell","service","need"],"title_tokens":["startup","option","settings","runonstartup"],"anchors":[]}]